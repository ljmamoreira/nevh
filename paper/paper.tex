\documentclass{iopart}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{bbm}
\expandafter\let\csname equation*\endcsname\relax
\expandafter\let\csname endequation*\endcsname\relax
\usepackage{amsmath}
\newcommand{\pd}[2]{\frac{\partial#1}{\partial#2}}
\newcommand{\undertilde}[1]{\underset{\tilde{}}{#1}}
\newcommand{\hmatrix}{\ensuremath{%
  \begin{pmatrix}
    \mathbbm{O}&\mathbbm{I}\\-\mathbbm{I}&\mathbbm{O}
  \end{pmatrix}
}}


\begin{document}
\title{Numerical Evolution from the Hamiltonian}
\author{José M L Amoreira$^1$ and Luís J M Amoreira$^2$}
\address{$^1$ Departamento de Física, Instituto Superior Técnico, Lisboa,
Portugal}
\address{$^2$ Departamento de Física, Universidade da Beira Interior, Covilhã,
Portugal}
\ead{amoreira@ubi.pt}
\begin{abstract}
  We propose a numerical method for the approximate calculation of the time
  evolution of point particle systems given only the system's hamiltonian
  function and initial condition. The numerical method both generates \emph{and}
  solves the equations of motion numerically. For demonstration purposes, a
  working im\-ple\-men\-ta\-tion (written in \texttt{python}) is described and
  applied to standard problems. The method may have some pedagogical merits but
  the numerical effort of generating the equations of motion makes it unsuitable
  for actual numerical solution of ``real'' problems with any but just a few
  degrees of freedom.
\end{abstract}
\noindent{\it Keywords\/}: Classical particle dynamics,
Hamilton's equations,
Numerical methods

\submitto{\EJP}
%\maketitle
\section{Introduction}
In the hamiltonian formulation of classical mechanics, the time evolutin of
physical systems is governed by Hamilton's equations which, for point particle
systems, take the form
\begin{align}
  \dot q_i&=\pd{H}{p_i}&
  \dot p_i&=-\pd{H}{q_i},
\end{align}
for $i=1,\;\ldots,\;F$ where $F$ is the number of degrees of freedom of the
system (three times the number of particles for unconstrained, three dimensional
systems), $q_i$, $p_i$ are the canonical coordinates and conjugate momenta
respectively, and $H=H(t, q_i, p_i)$ is the hamiltonian function of the system
(for XXX systems, the hamiltonian function is simply the mechanical energy of
the system). For discrete systems, these equations are a set of first order
ordinary differential equations (ODE) in time, whose solutions for given initial
conditions are the trajectories folowed by the system's particles.

In all but a small handfull of very well known simple problems, this system of
ODEs must be solved numerically. The usual approach in such cases is to obtain
explicit expressions for the partial derivatives of the hamiltonian function
(the right hand sides of Hamilton's equations) and to code those expressions in
subprograms which are then supplied to a standard ODE solver subroutine. In this
work, we propose an alternative numerical method, where the user only supplies
the hamiltonian function of the system, leaving its partial derivatives to be
computed numerically by the ODE solver itself.

This procedure is computationally more expensive, since many evaluations of the
hamiltonian function are needed in order to estimate its partial derivatives at
any moment in time, and so it really is not suitable to the analysis of complex
systems with more than just a few coupled degreess of freedom. However, for
simple systems it is very practical and, anyway, it is an interesting concept in
it own that we haven't seen exposed elsewhere.

%-------------------------------------------------------------------------------
\section{Numerical procedure}
%The standard, reasonable approach to the problem of finding the trajectories of
%$N$ interacting point particles using Hamilton's equations is as follows: one
%first derives analytical expressions for the partial derivatives $\partial
%H/\partial q_i$, $\partial H/\partial p_j$ of the system's Hamilton function;
%next, these expressions are programmed and the code is supplied to some
%computational routine implementing a numerical algorithm for ODEs, like Euler,
%Runge-Kutta, etc. Such routines are readily available for virtually all
%programming languages and interactve computational environments.
Standard numerical routines for solving systems of ODEs expect the problem to be
formulated in the form
\begin{equation}\label{eq:s_ode}
  \frac{d\tilde{\psi}}{dt}=\tilde{G}(t, \tilde{\psi})
\end{equation}
where $\tilde\psi$ is an array with the functions to be determined and $\tilde
G$ is a function of time and $\tilde\psi$. In Hamilton's equations for a system
of $F$ degrees of freedom, we have
\begin{equation}\label{eq:hpsi}
  \tilde\psi(t)=[q_1(t), \ldots, q_F(t), p_1(t), \ldots, p_F(t)],\qquad
  H=H(t,\tilde\psi)
\end{equation}
and
\begin{equation}\label{eq:heqsg}
  \tilde G(t, \tilde\psi)=
  \hmatrix
  \tilde\nabla H(t,\tilde{\psi})
\end{equation}
where $\mathbbm{O}$ and $\mathbbm{I}$ are, respectively, the $F\times F$ null
and identity matrices and $\tilde\nabla H$ is a $2F$ componet column array whose
elements are the
partial derivatives of the hamiltonian function in order to the coordinate and 
conjugate momentum variables $q_i$ and $p_j$,
\begin{equation}
  \tilde\nabla H = 
  \begin{pmatrix}
    \partial H/\partial q_1\\
    \vdots\\
    \partial H/\partial p_F
  \end{pmatrix}.
\end{equation}

Usually, expressions for the partial derivatives of the hamiltonian function are
deduced analitically and programmed in suitable form for being repeatedly called
from the computational ODE solver routine. That is, the rhs of eq.
(\ref{eq:s_ode}) is explicitly supplied by the user. Instead, in the method now
proposed, the user only supplies the code for the calculation of hamiltonian
function, and it's up to the numerical ODE solver to compute the hamiltonian's
partial derivatives as needed.

Let us consider a concrete problem and ODE solver to better differenciate the
two alternatives. Take the simple harmonic oscilator, solved using the explicit
forward Euler method~\cite{sir:2010}. The hamiltonian function is
\begin{equation}
  H(q,p) = \frac{1}{2}kq^2+\frac{p^2}{2m},
\end{equation}
where $k$ is the elastic constant of the restoring force and $m$ is the mass of
the oscilator.

%The solution of the system~(\ref{eq:s_ode})
%given~\eqref{eq:hpsi}
%and~\eqref{eq:heqsg} is obtained using the explicit forward Euler
%method~\cite{sir:2010} by iterative application of the formula
%\begin{equation*}
%  \tilde\psi(t+\delta t)=\tilde\psi(t)+\delta t
%  \hmatrix\tilde\nabla H(t,\tilde\psi(t))
%\end{equation*}

\section{Simple implementation in \texttt{python} and examples}
\section{Conclusion}

\section*{References}
\begin{thebibliography}{99}
  \bibitem{gol:1980} H. Goldstein, \textsl{Classical Mechanics.} Addison-Wesley
  (1980)
  \bibitem{sir:2010} S. \v{S}irca, M. Horvat, \textsl{Computational Methods in
  Physics.} Springer (2012)
  \bibitem{nr:2007} W.H.~Press, S.A.~Teukolsky, W.T.~Vetterling, B.P.~Flannery,
  \textsl{Numerical Recipes -- The Art of Scientific Computing,} 3rd Ed.
  Cambridge University Press (2007)
\end{thebibliography}
\end{document}
