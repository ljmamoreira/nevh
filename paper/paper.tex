\documentclass{iopart}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{bbm}
\expandafter\let\csname equation*\endcsname\relax
\expandafter\let\csname endequation*\endcsname\relax
\usepackage{amsmath}
\newcommand{\pd}[2]{\frac{\partial#1}{\partial#2}}
\newcommand{\undertilde}[1]{\underset{\tilde{}}{#1}}
\newcommand{\hmatrix}{\ensuremath{%
  \begin{pmatrix}
    \mathbbm{O}&\mathbbm{I}\\-\mathbbm{I}&\mathbbm{O}
  \end{pmatrix}
}}
\newcommand{\numap}[1]{\ensuremath{%
    \left\lfloor#1\right\rceil
}}


\begin{document}
\title{Numerical Evolution from the Hamiltonian}
\author{José M L Amoreira$^1$ and Luís J M Amoreira$^2$}
\address{$^1$ Departamento de Física, Instituto Superior Técnico, Lisboa,
Portugal}
\address{$^2$ Departamento de Física, Universidade da Beira Interior, Covilhã,
Portugal}
\ead{amoreira@ubi.pt}
\begin{abstract}
  We propose a numerical method for the approximate calculation of the time
  evolution of point particle systems given only the system's hamiltonian
  function and initial condition. The numerical method both generates \emph{and}
  solves the equations of motion numerically. For demonstration purposes, a
  working im\-ple\-men\-ta\-tion (written in \texttt{python}) is described and
  applied to standard problems. The method may have some pedagogical merits but
  the numerical effort of generating the equations of motion makes it unsuitable
  for actual numerical solution of ``real'' problems with any but just a few
  degrees of freedom.
\end{abstract}
\noindent{\it Keywords\/}: Classical particle dynamics,
Hamilton's equations,
Numerical methods

\submitto{\EJP}
%\maketitle
\section{Introduction}
In the hamiltonian formulation of classical mechanics~\cite{gol:1980}, the time
evolution of physical systems is governed by Hamilton's equations which, for
point particle systems, take the form
\begin{align}\label{eq:heqs}
  \dot q_i&=\pd{H}{p_i}&
  \dot p_i&=-\pd{H}{q_i},
\end{align}
for $i=1,\;\ldots,\;N,$ where $N$ is the number of degrees of freedom of the
system (three times the number of particles for unconstrained, three dimensional
systems), $q_i$, $p_i$ are the canonical coordinates and conjugate momenta
respectively, $H=H(t, q_i, p_i)$ is the hamiltonian function of the system
(for XXX systems, the hamiltonian function is simply the mechanical energy of
the system) and dotted symbols denote their total derivative with respect to
time. For discrete systems, these equations are a set of first order
ordinary differential equations (ODE) in time, whose solutions for given initial
conditions are the trajectories folowed by the system's particles.

In all but a small handfull of very well known simple problems, this system of
ODEs must be solved numerically. The usual approach in such cases is to obtain
explicit expressions for the partial derivatives of the hamiltonian function
(the right hand sides of Hamilton's equations) and to code those expressions in
subprograms which are then supplied to a standard ODE solver subroutine. In this
work, we propose an alternative numerical method, where the user only supplies
the hamiltonian function of the system, leaving its partial derivatives to be
computed numerically by the ODE solver itself.

This procedure is computationally more expensive, since many evaluations of the
hamiltonian function are needed in order to estimate its partial derivatives at
any moment in time, and so it really is not suitable to the analysis of complex
systems with more than just a few coupled degreess of freedom. However, for
simple systems it is very practical and, anyway, it is an interesting concept in
it own that we haven't seen exposed elsewhere.

%-------------------------------------------------------------------------------
\section{Numerical procedure}
Standard numerical routines for solving systems of ODEs expect the problem to be
written in the form
\begin{equation}\label{eq:numheqs}
  \frac{d\psi_i}{dt}=G_i(t, \psi_1, \psi_2, \ldots),\quad i=1, \ldots, N,
\end{equation}
where $N$ is the number of unknown functions $\psi_i(t)$ (and the number of
equations in well posed problems) and $G_i(t, \psi_1, \psi_2, \ldots)\equiv
G_i(t,\psi)$ are the rhs of the differential equations, wich must be coded by
the user as callable subprograms. The ODE
solver routine automatically invokes these subprograms in order (as many times
as required by the sspecific method and/or desired accuracy) to compute
estimates of the unknown functions $\psi_i$.

For Hamilton's equations, the $\psi_i$ are the coordinates and momenta, while
the $G_i$ are the partial derivatives of the hamiltonian function, for which, in
the standard approach, the user must derive expressions to be programmed.
Instead, in the method now proposed, only the hamiltonian function is coded and
the ODE solver is modified so that it repeatedly invokes that subprogram in
order to compute the hamiltonian's partial derivatives numerically. Only then
does it proceed to the estimation of the ODE solution.

To make this discussion clearer, let's consider a specific problem, the
classical harmonic oscilator~\cite{french:71}, and a specific ODE solver method,
the explicit forward Euler method \cite{sir:2010}. The hamiltonian function for
a classical oscilator with mass $m$ and restoring force constant $k$ is 
\begin{equation}
  H(q,p)=\frac{1}{2}kq^2+\frac{p^2}{2m}.
\end{equation}
Hamilton's equations~\eqref{eq:heqs} then read
\begin{align}
  \frac{dq}{dt}&=\frac{p}{m}&
  \frac{dp}{dt}&=-kq,
\end{align}
wich are already in the form of eq.~\eqref{eq:numheqs}. Given initial values
$q_0$ and $p_0,$ successive values can be estimated at times $t_1$, $t_2$, \ldots
by iterating the formulas
\begin{align}
  q_{i+1}&=q_{i}+\frac{p_i}{m}\delta t_i\label{eq:efe1}\\
  p_{i+1}&=p_{i}-kq_i\delta t_i\label{eq:efe2},
\end{align}
where $\delta t_i=t_{i+1}-t_i$. It is now easy to write a  program that
implements this method, and this the usual procedure. With this paper, we
consider a method where explicit expressions for the hamiltonian's partial
derivatives in the equations of motion are replaced by numerical estimates. In
our toy problem, that amounts to rewriting eqs~\eqref{eq:efe1}
and~\eqref{eq:efe2} by
\begin{align*}
  q_{i+1}&=q_{i}+\numap{\frac{\partial H}{\partial p}}_i \delta t_i\\
  p_{i+1}&=p_{i}-\numap{\frac{\partial H}{\partial q}}_i\delta t_i,
\end{align*}
where $\numap{X}_i$ means \emph{numerical approximation of $X$ at time $t_i$.}
In order to make numerical aproximations to the partial derivatives of a
function, one must evaluate it several times; at the very least, two evaluations
are needed. For example, using the central difference method, the derivative is
estimated as
\begin{equation} 
  \frac{\partial\psi}{\partial x} = 
    \frac{\psi(x+\delta x)-\psi(x-\delta t)}{2\delta x}+
  o(\delta x)^2,
\end{equation}
leading to approximation formulas that, for our example problem, read 
\begin{align}
  \numap{\frac{\partial H}{\partial p}}_i &=
  \frac{H(q_i, p_i+\delta p)-H(q_i, p_i-\delta p)}{2\delta p}\\
  \numap{\frac{\partial H}{\partial q}}_i &=
  \frac{H(q_i+\delta q, p_i)-H(q_i-\delta q, p_i)}{2\delta q},
\end{align}
where $\delta q$ and $\delta p$ are suitably chosen discretization parameters.
Other approximations have higher accuracy, at the cost of extra evaluations of
the function to be derived.

This need for repeated evaluation of the system's hamiltonian reduces the
efficiency of this method. However, programming a procedure for the hamiltonian
function is usually much simpler then doing it for the set of its partial
derivatives.  Also, adjusting the syntax and semantics of the ODE solver and the
hamiltonian procedure is likewise much simpler than when the partial derivatives
are coded.  For small systems, using the hamiltonian is much simpler and faster.



\section{Simple implementation in \texttt{python} and examples}
\section{Conclusion}

\section*{References}
\begin{thebibliography}{99}
  \bibitem{gol:1980} H. Goldstein, \textsl{Classical Mechanics.} Addison-Wesley
  (1980)
  \bibitem{french:71} A.P.~French, \textsl{Vibration and Waves.} W.W. Norton \&
  Company (1971)
  \bibitem{sir:2010} S. \v{S}irca, M. Horvat, \textsl{Computational Methods in
  Physics.} Springer (2012)
  \bibitem{nr:2007} W.H.~Press, S.A.~Teukolsky, W.T.~Vetterling, B.P.~Flannery,
  \textsl{Numerical Recipes -- The Art of Scientific Computing,} 3rd Ed.
  Cambridge University Press (2007)
\end{thebibliography}
\end{document}
